<!-- <!DOCTYPE html>
<html>
<head>
<title>Crashing Page</title>
<style>
  body { font-family: sans-serif; }
</style>
</head>
<body>
  <h1>Crashing page</h1>
  <p>This page attempts to crash the browser tab by consuming memory in a loop.</p>
  <p>If crash recovery (like reloading) is implemented, this page might enter an infinite reload loop.</p>
  <script>
    console.log("Starting memory allocation loop...");
    let buffer = [];
    let counter = 0;
    const allocationSizeMB = 50;
    const interval = 10; // ms
    let intervalId = null;

    function allocate() {
      try {
        buffer.push(new Uint8Array(allocationSizeMB * 1024 * 1024));
        counter++;
        // console.log(`Allocated ${counter} times`);
      } catch (e) {
        console.error("Error allocating memory:", e);
        // If allocation fails (e.g., JS heap limit reached),
        // clear interval to prevent console spam.
        if (intervalId) {
          clearInterval(intervalId);
          intervalId = null;
          console.log(`Stopped allocation after ${counter} successful allocations.`);
        }
      }
    }

    window.addEventListener('load', () => {
      intervalId = setInterval(allocate, interval);
    });
  </script>
</body>
</html> -->
<!-- 
<!DOCTYPE html>
<html>
<head>
<title>Crashing Page - Aggressive</title>
<style>
  body { font-family: sans-serif; -webkit-user-select: none; }
</style>
</head>
<body>
  <h1>Crashing page - Aggressive</h1>
  <p>This page attempts to crash the browser tab by consuming memory rapidly using Web Workers.</p>
  <script>
    console.log("Starting aggressive memory allocation loop...");

    const ALLOC_SIZE_MB = 100; // Size of each allocation chunk in MB
    const INTERVAL_MS = 10;    // Interval between allocations per thread in ms
    const NUM_WORKERS = 4;     // Number of parallel worker threads to spawn

    /**
     * The script that will run in each Web Worker.
     * It allocates memory in a loop and stores it in an array
     * to prevent garbage collection.
     */
    const workerScript = `
      self.leakedMemory = [];
      // console.log('Worker started: Allocating ${ALLOC_SIZE_MB}MB every ${INTERVAL_MS}ms');
      setInterval(() => {
        try {
          self.leakedMemory.push(new Uint8Array(${ALLOC_SIZE_MB} * 1024 * 1024));
        } catch (e) {
          // Error is expected when heap limit is reached or allocation fails.
          // We don't stop or log, just continue trying.
        }
      }, ${INTERVAL_MS});
    `;

    /**
     * Creates and starts one Web Worker.
     */
    function startWorker(id) {
      try {
        const blob = new Blob([workerScript], {type: 'application/javascript'});
        const worker = new Worker(URL.createObjectURL(blob));
        worker.onerror = (e) => console.error(`Worker ${id} error:`, e);
      } catch (e) {
        console.error(`Failed to start worker ${id}:`, e);
      }
    }

    // --- Main Thread Allocation ---
    // console.log(`Main thread: Allocating ${ALLOC_SIZE_MB}MB every ${INTERVAL_MS}ms`);
    let mainThreadLeak = [];
    setInterval(() => {
        try {
          mainThreadLeak.push(new Uint8Array(ALLOC_SIZE_MB * 1024 * 1024));
        } catch (e) {
          // Ignore errors
        }
      }, INTERVAL_MS);

    // --- Worker Thread Allocation ---
    console.log(`Starting ${NUM_WORKERS} workers for parallel allocation.`);
    for (let i = 0; i < NUM_WORKERS; i++) {
      startWorker(i);
    }

  </script>
</body>
</html> -->

<!-- <!DOCTYPE html>
<html>
<head>
<title>Crashing Page - Blob URL Leak</title>
<style>
  body { font-family: sans-serif; }
</style>
</head>
<body>
  <h1>Crashing page - Blob URL Leak</h1>
  <p>This page attempts to crash by leaking memory via <code>URL.createObjectURL</code>.</p>
  <p>Each call creates an object URL backed by Blob data, which consumes memory until the document is destroyed or the URL is revoked. By never revoking, we force memory usage to grow.</p>
  <script>
    console.log("Starting Blob URL leak...");
    let count = 0;
    const blobSize = 20 * 1024 * 1024; // 20MB
    const interval = 10; // ms

    function leakBlob() {
      try {
        // We need to create a new buffer each time to consume new memory.
        const buffer = new Uint8Array(blobSize);
        const blob = new Blob([buffer], {type: 'application/octet-stream'});
        // Create object URL and immediately "forget" it.
        // It remains in memory, tied to the document's URL store, until
        // revokeObjectURL is called or the page is unloaded.
        URL.createObjectURL(blob);
        count++;
        // Log every 50 iterations (1GB)
        if (count % 50 === 0) {
          console.log(`Leaked ${count} Blob URLs, totalling ${count * blobSize / 1024 / 1024} MB`);
        }
      } catch (e) {
        console.error("Failed to create Blob or URL:", e);
      }
    }
    setInterval(leakBlob, interval);
  </script>
</body>
</html> -->


<!-- <!DOCTYPE html>
<html>
<head>
<title>Crashing Page - Blob URL Leak</title>
<style>
  body { font-family: sans-serif; }
</style>
<script>
    console.log("Starting Blob URL leak...");
    let count = 0;
    const blobSize = 20 * 1024 * 1024; // 20MB
    const interval = 1; // ms

    function leakBlob() {
      try {
        // We need to create a new buffer each time to consume new memory.
        const buffer = new Uint8Array(blobSize);
        const blob = new Blob([buffer], {type: 'application/octet-stream'});
        // Create object URL and immediately "forget" it.
        // It remains in memory, tied to the document's URL store, until
        // revokeObjectURL is called or the page is unloaded.
        URL.createObjectURL(blob);
        count++;
        // Log every 50 iterations (1GB)
        if (count % 50 === 0) {
          console.log(`Leaked ${count} Blob URLs, totalling ${count * blobSize / 1024 / 1024} MB`);
        }
      } catch (e) {
        console.error("Failed to create Blob or URL:", e);
      }
    }
    setInterval(leakBlob, interval);
  </script>
</head>
<body>
  <h1>Crashing page - Blob URL Leak</h1>
  <p>This page attempts to crash by leaking memory via <code>URL.createObjectURL</code>.</p>
  <p>Each call creates an object URL backed by Blob data, which consumes memory until the document is destroyed or the URL is revoked. By never revoking, we force memory usage to grow.</p>
</body>
</html> -->


<!DOCTYPE html>
<html>
<head>
<title>Crashing Page</title>
<style>
  body { font-family: sans-serif; }
  .tabs { margin-bottom: 10px; }
  .tabs button { padding: 10px; cursor: pointer; }
  .tabs button.active { background-color: #ccc; font-weight: bold; }
  .tab-content { display: none; border: 1px solid #ccc; padding: 10px; margin-top: -1px;}
  .tab-content.active { display: block; }
  #indicator {
    width: 20px;
    height: 20px;
    background-color: green;
    border-radius: 50%;
    animation: blink 1s infinite;
    margin-top: 10px;
    display: inline-block;
    vertical-align: middle;
  }
  @keyframes blink {
    0% { opacity: 1; }
    50% { opacity: 0.2; }
    100% { opacity: 1; }
  }
  #interaction-button {
    padding: 8px 12px;
    margin-left: 10px;
  }
</style>
</head>
<body>
  <h1>Crashing page</h1>
  <p>This page attempts to crash in multiple ways. The blinking dot indicates if page is responsive.</p>
  <div>
    <div id="indicator" title="If blinking, page is responsive"></div>
    Responsive check: <span id="timer">0</span>s
    <button id="interaction-button">Click to change color</button>
  </div>

  <div class="tabs">
    <button id="tab1-btn" class="tab-btn active">PostMessage Flood</button>
    <button id="tab2-btn" class="tab-btn">History Flood</button>
    <button id="tab3-btn" class="tab-btn">Memory Leak</button>
  </div>

  <div id="tab1-content" class="tab-content active">
    <h2>PostMessage Flood</h2>
    <p>Floods postMessage with large blobs to exhaust IPC or memory.</p>
    <button onclick="startPostMessageFlood(this)">Start</button>
  </div>

  <div id="tab2-content" class="tab-content">
    <h2>History Flood</h2>
    <p>Calls history.pushState in an infinite loop. This will hang the page.</p>
    <button onclick="startHistoryFlood(this)">Start</button>
  </div>

  <div id="tab3-content" class="tab-content">
    <h2>Memory Leak</h2>
    <p>Continuously allocates large ArrayBuffers to exhaust memory.</p>
    <button onclick="startMemoryLeak(this)">Start</button>
  </div>

<script>
  // --- Responsiveness checks ---
  let time = 0;
  setInterval(() => {
    time++;
    document.getElementById('timer').innerText = time;
  }, 1000);

  const interactionButton = document.getElementById('interaction-button');
  interactionButton.onclick = () => {
    const randomColor = '#' + Math.floor(Math.random()*16777215).toString(16);
    interactionButton.style.backgroundColor = randomColor;
    interactionButton.style.color = '#000';
  };

  // --- Tab logic ---
  const tabBtns = document.querySelectorAll('.tab-btn');
  const tabContents = document.querySelectorAll('.tab-content');
  tabBtns.forEach(btn => {
    btn.addEventListener('click', (event) => {
      const tabId = event.target.id; // e.g. tab1-btn
      const contentId = tabId.replace('-btn', '-content'); // e.g. tab1-content

      tabBtns.forEach(b => b.classList.remove('active'));
      tabContents.forEach(c => c.classList.remove('active'));

      event.target.classList.add('active');
      document.getElementById(contentId).classList.add('active');
    });
  });

  // --- Crash methods ---

  // 1. PostMessage Flood
  function startPostMessageFlood(btn) {
    btn.disabled = true;
    btn.innerText = 'Running...';
    console.log('Starting PostMessage flood...');
    var blob = new Blob([new ArrayBuffer(1024*1024*10)]);
    function bombe(){
      window.postMessage(blob,"*");
    }
    window.addEventListener('message', bombe);
    bombe();
  }

  // 2. History Flood
  function startHistoryFlood(btn) {
    btn.disabled = true;
    btn.innerText = 'Running...';
    console.log('Starting History flood...');
    while(true) {
      history.pushState({}, '');
    }
  }

  // 3. Memory Leak
  let leaks = [];
  function startMemoryLeak(btn) {
    btn.disabled = true;
    btn.innerText = 'Running...';
    console.log('Starting memory leak...');
    function leak() {
      leaks.push(new ArrayBuffer(1024*1024*10)); // 10MB
      setTimeout(leak, 50);
    }
    leak();
  }

</script>
</body>
</html>