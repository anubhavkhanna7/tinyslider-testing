<!-- <!DOCTYPE html>
<html>
<head>
<title>Crashing Page</title>
<style>
  body { font-family: sans-serif; }
</style>
</head>
<body>
  <h1>Crashing page</h1>
  <p>This page attempts to crash the browser tab by consuming memory in a loop.</p>
  <p>If crash recovery (like reloading) is implemented, this page might enter an infinite reload loop.</p>
  <script>
    console.log("Starting memory allocation loop...");
    let buffer = [];
    let counter = 0;
    const allocationSizeMB = 50;
    const interval = 10; // ms
    let intervalId = null;

    function allocate() {
      try {
        buffer.push(new Uint8Array(allocationSizeMB * 1024 * 1024));
        counter++;
        // console.log(`Allocated ${counter} times`);
      } catch (e) {
        console.error("Error allocating memory:", e);
        // If allocation fails (e.g., JS heap limit reached),
        // clear interval to prevent console spam.
        if (intervalId) {
          clearInterval(intervalId);
          intervalId = null;
          console.log(`Stopped allocation after ${counter} successful allocations.`);
        }
      }
    }

    window.addEventListener('load', () => {
      intervalId = setInterval(allocate, interval);
    });
  </script>
</body>
</html> -->
<!-- 
<!DOCTYPE html>
<html>
<head>
<title>Crashing Page - Aggressive</title>
<style>
  body { font-family: sans-serif; -webkit-user-select: none; }
</style>
</head>
<body>
  <h1>Crashing page - Aggressive</h1>
  <p>This page attempts to crash the browser tab by consuming memory rapidly using Web Workers.</p>
  <script>
    console.log("Starting aggressive memory allocation loop...");

    const ALLOC_SIZE_MB = 100; // Size of each allocation chunk in MB
    const INTERVAL_MS = 10;    // Interval between allocations per thread in ms
    const NUM_WORKERS = 4;     // Number of parallel worker threads to spawn

    /**
     * The script that will run in each Web Worker.
     * It allocates memory in a loop and stores it in an array
     * to prevent garbage collection.
     */
    const workerScript = `
      self.leakedMemory = [];
      // console.log('Worker started: Allocating ${ALLOC_SIZE_MB}MB every ${INTERVAL_MS}ms');
      setInterval(() => {
        try {
          self.leakedMemory.push(new Uint8Array(${ALLOC_SIZE_MB} * 1024 * 1024));
        } catch (e) {
          // Error is expected when heap limit is reached or allocation fails.
          // We don't stop or log, just continue trying.
        }
      }, ${INTERVAL_MS});
    `;

    /**
     * Creates and starts one Web Worker.
     */
    function startWorker(id) {
      try {
        const blob = new Blob([workerScript], {type: 'application/javascript'});
        const worker = new Worker(URL.createObjectURL(blob));
        worker.onerror = (e) => console.error(`Worker ${id} error:`, e);
      } catch (e) {
        console.error(`Failed to start worker ${id}:`, e);
      }
    }

    // --- Main Thread Allocation ---
    // console.log(`Main thread: Allocating ${ALLOC_SIZE_MB}MB every ${INTERVAL_MS}ms`);
    let mainThreadLeak = [];
    setInterval(() => {
        try {
          mainThreadLeak.push(new Uint8Array(ALLOC_SIZE_MB * 1024 * 1024));
        } catch (e) {
          // Ignore errors
        }
      }, INTERVAL_MS);

    // --- Worker Thread Allocation ---
    console.log(`Starting ${NUM_WORKERS} workers for parallel allocation.`);
    for (let i = 0; i < NUM_WORKERS; i++) {
      startWorker(i);
    }

  </script>
</body>
</html> -->

<!-- <!DOCTYPE html>
<html>
<head>
<title>Crashing Page - Blob URL Leak</title>
<style>
  body { font-family: sans-serif; }
</style>
</head>
<body>
  <h1>Crashing page - Blob URL Leak</h1>
  <p>This page attempts to crash by leaking memory via <code>URL.createObjectURL</code>.</p>
  <p>Each call creates an object URL backed by Blob data, which consumes memory until the document is destroyed or the URL is revoked. By never revoking, we force memory usage to grow.</p>
  <script>
    console.log("Starting Blob URL leak...");
    let count = 0;
    const blobSize = 20 * 1024 * 1024; // 20MB
    const interval = 10; // ms

    function leakBlob() {
      try {
        // We need to create a new buffer each time to consume new memory.
        const buffer = new Uint8Array(blobSize);
        const blob = new Blob([buffer], {type: 'application/octet-stream'});
        // Create object URL and immediately "forget" it.
        // It remains in memory, tied to the document's URL store, until
        // revokeObjectURL is called or the page is unloaded.
        URL.createObjectURL(blob);
        count++;
        // Log every 50 iterations (1GB)
        if (count % 50 === 0) {
          console.log(`Leaked ${count} Blob URLs, totalling ${count * blobSize / 1024 / 1024} MB`);
        }
      } catch (e) {
        console.error("Failed to create Blob or URL:", e);
      }
    }
    setInterval(leakBlob, interval);
  </script>
</body>
</html> -->


<!DOCTYPE html>
<html>
<head>
<title>Crashing Page - Blob URL Leak</title>
<style>
  body { font-family: sans-serif; }
</style>
<script>
    console.log("Starting Blob URL leak...");
    let count = 0;
    const blobSize = 20 * 1024 * 1024; // 20MB
    const interval = 1; // ms

    function leakBlob() {
      try {
        // We need to create a new buffer each time to consume new memory.
        const buffer = new Uint8Array(blobSize);
        const blob = new Blob([buffer], {type: 'application/octet-stream'});
        // Create object URL and immediately "forget" it.
        // It remains in memory, tied to the document's URL store, until
        // revokeObjectURL is called or the page is unloaded.
        URL.createObjectURL(blob);
        count++;
        // Log every 50 iterations (1GB)
        if (count % 50 === 0) {
          console.log(`Leaked ${count} Blob URLs, totalling ${count * blobSize / 1024 / 1024} MB`);
        }
      } catch (e) {
        console.error("Failed to create Blob or URL:", e);
      }
    }
    setInterval(leakBlob, interval);
  </script>
</head>
<body>
  <h1>Crashing page - Blob URL Leak</h1>
  <p>This page attempts to crash by leaking memory via <code>URL.createObjectURL</code>.</p>
  <p>Each call creates an object URL backed by Blob data, which consumes memory until the document is destroyed or the URL is revoked. By never revoking, we force memory usage to grow.</p>
</body>
</html>